<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>SimplicialSurface</title>
		<style>
			body { margin: 0; }
		</style>


	</head>
	<body>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>


<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.148.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/",
			"gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
		}
	}
</script>


<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { GUI } from 'gui';
	import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';

	//start scene and camera
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );

	const renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	//Lights
	const skyColor = 0xFFFFFF;
	const skyIntensity = 0.3;
	const skyLight = new THREE.AmbientLight(skyColor, skyIntensity);
	scene.add(skyLight);

	const color = 0xFFFFFF;
	const intensity = 1;
	const light = new THREE.PointLight(color, intensity);
	light.position.set(0, 3, -5);
	scene.add(light);

	//create groups to add everything to
	const meshRoot = new THREE.Group();
	const wireRoot = new THREE.Group();
	const vertexRoot = new THREE.Group();
	const vertexlabelRoot = new THREE.Group();
	const edgeRoot = new THREE.Group();
	const ringRoot = new THREE.Group();
	const normalsRoot = new THREE.Group();
	const normalMeshRoot = new THREE.Group();

	//parameters for the controls on the top right
	var guiParameters = new function() { 
		this.speedX = 0.0; 
		this.speedY = 0.0; 
		this.speedZ = 0.0;
		this.transparency = 1;
		this.edgeVisibility = false;
		this.edgeWidth = 0.2;

		this.vertexVisibility = true;
		this.vertexlabelVisibility = false;
		this.vertexSize = 1;
		this.planeX = 0.0;
		this.minX = -1.5;
		this.maxX = 1.5;
		this.planeXactive = false;
		this.planeY = 0.0;
		this.minY = -1.5;

		this.maxY = 1.5;
		this.planeYactive = false;
		this.planeZ = 0.0;
		this.minZ = -1.5;
		this.maxZ = 1.5;
		this.planeZactive = false;
		this.normalsMaterial = false;
		this.circleVisibility = false;
		this.circleWidth = 0.005;
		this.normalsVisibility = false;
		this.normalsLength = 1;
	} ;

	//generate the plane for intersections
	const planeX = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), guiParameters.planeX );
	const planeY = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), guiParameters.planeY );
	const planeZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), guiParameters.planeZ );

	// the array which ones are currently active
	var activePlanes = [];

	//rederer for lables
	const labelRenderer = new CSS2DRenderer();
	labelRenderer.setSize( window.innerWidth, window.innerHeight );
	labelRenderer.domElement.style.position = 'absolute';
	labelRenderer.domElement.style.top = '0px';
	document.body.appendChild( labelRenderer.domElement );
	
	//controls for mouse 
	const controls = new OrbitControls( camera, labelRenderer.domElement );

	//controls in the top right corner
	var gui = new GUI();

	const animationFolder = gui.addFolder("Animations");
	animationFolder.add(guiParameters, 'speedX', 0, 5);
	animationFolder.add(guiParameters, 'speedY', 0, 5);
	animationFolder.add(guiParameters, 'speedZ', 0, 5);
	animationFolder.open();

	const controlFolder = gui.addFolder("Controls");
	controlFolder.add(guiParameters, "transparency", 0, 1);
	controlFolder.add(guiParameters, "edgeVisibility");
	var edgeWidthGUI = controlFolder.add(guiParameters, "edgeWidth", 0.01, 2);
	controlFolder.add(guiParameters, "vertexVisibility");
	controlFolder.add(guiParameters, "vertexlabelVisibility");
	controlFolder.add(guiParameters, "vertexSize", 0.1, 3);
	controlFolder.add(guiParameters, "normalsMaterial");
	controlFolder.add(guiParameters, "circleVisibility");
	controlFolder.add(guiParameters, "circleWidth", 0.0001, 0.1);
	controlFolder.add(guiParameters, "normalsVisibility");
	controlFolder.add(guiParameters, "normalsLength", 0, 2);
	controlFolder.open();

	//generate a sphere geometry for the vertices
	const sphereGeometry = new THREE.SphereGeometry( 0.02, 32, 16 );
	sphereGeometry.transparent = guiParameters.vertexVisibility;
	
	//functions for later calculations

	function calulateIncenter(A, B, C){
		//we follow the math and variable names from here: https://math.stackexchange.com/questions/740111/incenter-of-triangle-in-3d
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var res = [];
		res[0] = a/(a+b+c)*A[0] + b/(a+b+c)*B[0] + c/(a+b+c)*C[0];
		res[1] = a/(a+b+c)*A[1] + b/(a+b+c)*B[1] + c/(a+b+c)*C[1];
		res[2] = a/(a+b+c)*A[2] + b/(a+b+c)*B[2] + c/(a+b+c)*C[2];

		return res;
	}

	function calulateInradius(A, B, C){
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var s = (a+b+c)/2;
		var inradius = Math.sqrt(((s-a)*(s-b)*(s-c)) / s );

		return inradius;
	}

	// --- start of generated output --- //

	// preperations for parameterized vertex coordinates 
	const vertexParametriziation = false;
	// generate the faces color by color 
	const geometry1 = new THREE.BufferGeometry();
	function setVertices1(){
		var vertices1 = new Float32Array( [
				0,0,1.414213562373095,
			1,1,0,
			1.483163247594393,0.,1.048754789980658,

			0,0,1.414213562373095,
			1,-1,0,
			1.483163247594393,0.,1.048754789980658,

			1,1,0,
			1,-1,0,
			1.483163247594393,0.,1.048754789980658,

			1,1,0,
			-1,1,0,
			0.,1.483163247594393,-1.048754789980658,

			1,1,0,
			0,0,-1.414213562373095,
			0.,1.483163247594393,-1.048754789980658,

			-1,1,0,
			0,0,-1.414213562373095,
			0.,1.483163247594393,-1.048754789980658,

			0,0,1.414213562373095,
			1,1,0,
			0.,1.483163247594393,1.048754789980658,

			0,0,1.414213562373095,
			-1,1,0,
			0.,1.483163247594393,1.048754789980658,

			1,1,0,
			-1,1,0,
			0.,1.483163247594393,1.048754789980658,

			1,1,0,
			1,-1,0,
			1.483163247594393,0.,-1.048754789980658,

			1,1,0,
			0,0,-1.414213562373095,
			1.483163247594393,0.,-1.048754789980658,

			1,-1,0,
			0,0,-1.414213562373095,
			1.483163247594393,0.,-1.048754789980658,

			0,0,1.414213562373095,
			-1,-1,0,
			-1.483163247594393,0.,1.048754789980658,

			0,0,1.414213562373095,
			-1,1,0,
			-1.483163247594393,0.,1.048754789980658,

			-1,-1,0,
			-1,1,0,
			-1.483163247594393,0.,1.048754789980658,

			1,-1,0,
			-1,-1,0,
			0.,-1.483163247594393,-1.048754789980658,

			1,-1,0,
			0,0,-1.414213562373095,
			0.,-1.483163247594393,-1.048754789980658,

			-1,-1,0,
			0,0,-1.414213562373095,
			0.,-1.483163247594393,-1.048754789980658,

			0,0,1.414213562373095,
			1,-1,0,
			0.,-1.483163247594393,1.048754789980658,

			0,0,1.414213562373095,
			-1,-1,0,
			0.,-1.483163247594393,1.048754789980658,

			1,-1,0,
			-1,-1,0,
			0.,-1.483163247594393,1.048754789980658,

			-1,-1,0,
			-1,1,0,
			-1.483163247594393,0.,-1.048754789980658,

			-1,-1,0,
			0,0,-1.414213562373095,
			-1.483163247594393,0.,-1.048754789980658,

			-1,1,0,
			0,0,-1.414213562373095,
			-1.483163247594393,0.,-1.048754789980658,

					] ); 

		return vertices1; 
	}

	geometry1.setAttribute( 'position', new THREE.BufferAttribute( setVertices1(), 3 ) );

	// generate materials in the given color and normals material for the faces 

    const materialNormal1 = new THREE.MeshNormalMaterial({
        flatShading: true,
    });
    materialNormal1.transparent = true;
    materialNormal1.side = THREE.DoubleSide;
        
    const material1 = new THREE.MeshPhongMaterial({
        color: 0x049EF4,
        flatShading: true,
    });
    material1.transparent = true;
    material1.side = THREE.DoubleSide;
        
	// generate meshes for the faces from the materials with the vertex coordinates from before 

    const mesh1 = new THREE.Mesh( geometry1, material1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    meshRoot.add(mesh1);
        
    const meshNormal1 = new THREE.Mesh( geometry1, materialNormal1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    normalMeshRoot.add(meshNormal1);
        
	// generate the edges grouped by color
		controlFolder.remove(edgeWidthGUI);

    const edgeMaterial1 = new THREE.LineBasicMaterial( {
        color: 0x000000,
        lineWidth: 3.,
    } );
        
	function getEdges1(){
		const edges1 = new Float32Array( [
			0,0,1.4142135623730951,
			1,1,0,

			0,0,1.4142135623730951,
			1,-1,0,

			0,0,1.4142135623730951,
			-1,-1,0,

			0,0,1.4142135623730951,
			-1,1,0,

			1,1,0,
			1,-1,0,

			1,1,0,
			-1,1,0,

			1,1,0,
			0,0,-1.4142135623730951,

			1,-1,0,
			-1,-1,0,

			1,-1,0,
			0,0,-1.4142135623730951,

			-1,-1,0,
			-1,1,0,

			-1,-1,0,
			0,0,-1.4142135623730951,

			-1,1,0,
			0,0,-1.4142135623730951,

			0,0,1.4142135623730951,
			1.4831632475943928,0.,1.0487547899806575,

			1,1,0,
			1.4831632475943928,0.,1.0487547899806575,

			1,-1,0,
			1.4831632475943928,0.,1.0487547899806575,

			1,1,0,
			0.,1.4831632475943928,-1.0487547899806575,

			-1,1,0,
			0.,1.4831632475943928,-1.0487547899806575,

			0,0,-1.4142135623730951,
			0.,1.4831632475943928,-1.0487547899806575,

			0,0,1.4142135623730951,
			0.,1.4831632475943928,1.0487547899806575,

			1,1,0,
			0.,1.4831632475943928,1.0487547899806575,

			-1,1,0,
			0.,1.4831632475943928,1.0487547899806575,

			1,1,0,
			1.4831632475943928,0.,-1.0487547899806575,

			1,-1,0,
			1.4831632475943928,0.,-1.0487547899806575,

			0,0,-1.4142135623730951,
			1.4831632475943928,0.,-1.0487547899806575,

			0,0,1.4142135623730951,
			-1.4831632475943928,0.,1.0487547899806575,

			-1,-1,0,
			-1.4831632475943928,0.,1.0487547899806575,

			-1,1,0,
			-1.4831632475943928,0.,1.0487547899806575,

			1,-1,0,
			0.,-1.4831632475943928,-1.0487547899806575,

			-1,-1,0,
			0.,-1.4831632475943928,-1.0487547899806575,

			0,0,-1.4142135623730951,
			0.,-1.4831632475943928,-1.0487547899806575,

			0,0,1.4142135623730951,
			0.,-1.4831632475943928,1.0487547899806575,

			1,-1,0,
			0.,-1.4831632475943928,1.0487547899806575,

			-1,-1,0,
			0.,-1.4831632475943928,1.0487547899806575,

			-1,-1,0,
			-1.4831632475943928,0.,-1.0487547899806575,

			-1,1,0,
			-1.4831632475943928,0.,-1.0487547899806575,

			0,0,-1.4142135623730951,
			-1.4831632475943928,0.,-1.0487547899806575,

		]);
		return edges1;
	}


	// generate geometries and lines for the edges 

    const edgeGeometry1 = new THREE.BufferGeometry();
    edgeGeometry1.setAttribute( 'position', new THREE.BufferAttribute( getEdges1(), 3 ) );

    const edgeLine1 = new THREE.LineSegments( edgeGeometry1, edgeMaterial1 );
    edgeRoot.add(edgeLine1);
        
	// update function to be called every frame 


	function getVertex1(){
		return [0,0,1.4142135623730951,];
	}


	function getVertex2(){
		return [1,1,0,];
	}


	function getVertex3(){
		return [1,-1,0,];
	}


	function getVertex4(){
		return [-1,-1,0,];
	}


	function getVertex5(){
		return [-1,1,0,];
	}


	function getVertex6(){
		return [0,0,-1.4142135623730951,];
	}


	function getVertex7(){
		return [1.4831632475943928,0.,1.0487547899806575,];
	}


	function getVertex8(){
		return [0.,1.4831632475943928,-1.0487547899806575,];
	}


	function getVertex9(){
		return [0.,1.4831632475943928,1.0487547899806575,];
	}


	function getVertex10(){
		return [1.4831632475943928,0.,-1.0487547899806575,];
	}


	function getVertex11(){
		return [-1.4831632475943928,0.,1.0487547899806575,];
	}


	function getVertex12(){
		return [0.,-1.4831632475943928,-1.0487547899806575,];
	}


	function getVertex13(){
		return [0.,-1.4831632475943928,1.0487547899806575,];
	}


	function getVertex14(){
		return [-1.4831632475943928,0.,-1.0487547899806575,];
	}
	// generate labels and spheres for the vertices
	const sphereMaterial1 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere1 = new THREE.Mesh( sphereGeometry, sphereMaterial1 );
	vertexRoot.add(sphere1);
	sphere1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);

    const lableDiv1 = document.createElement( 'div' );
    lableDiv1.className = 'label';
    lableDiv1.textContent = '1';
    lableDiv1.style.marginTop = '-1em';

    const vertexLabel1 = new CSS2DObject( lableDiv1 );
    vertexLabel1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);
    vertexlabelRoot.add( vertexLabel1 );
            
            	const sphereMaterial2 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere2 = new THREE.Mesh( sphereGeometry, sphereMaterial2 );
	vertexRoot.add(sphere2);
	sphere2.position.set(getVertex2()[0],getVertex2()[1],getVertex2()[2]);

    const lableDiv2 = document.createElement( 'div' );
    lableDiv2.className = 'label';
    lableDiv2.textContent = '2';
    lableDiv2.style.marginTop = '-1em';

    const vertexLabel2 = new CSS2DObject( lableDiv2 );
    vertexLabel2.position.set(getVertex2()[0],getVertex2()[1],getVertex2()[2]);
    vertexlabelRoot.add( vertexLabel2 );
            
            	const sphereMaterial3 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere3 = new THREE.Mesh( sphereGeometry, sphereMaterial3 );
	vertexRoot.add(sphere3);
	sphere3.position.set(getVertex3()[0],getVertex3()[1],getVertex3()[2]);

    const lableDiv3 = document.createElement( 'div' );
    lableDiv3.className = 'label';
    lableDiv3.textContent = '3';
    lableDiv3.style.marginTop = '-1em';

    const vertexLabel3 = new CSS2DObject( lableDiv3 );
    vertexLabel3.position.set(getVertex3()[0],getVertex3()[1],getVertex3()[2]);
    vertexlabelRoot.add( vertexLabel3 );
            
            	const sphereMaterial4 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere4 = new THREE.Mesh( sphereGeometry, sphereMaterial4 );
	vertexRoot.add(sphere4);
	sphere4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);

    const lableDiv4 = document.createElement( 'div' );
    lableDiv4.className = 'label';
    lableDiv4.textContent = '4';
    lableDiv4.style.marginTop = '-1em';

    const vertexLabel4 = new CSS2DObject( lableDiv4 );
    vertexLabel4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);
    vertexlabelRoot.add( vertexLabel4 );
            
            	const sphereMaterial5 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere5 = new THREE.Mesh( sphereGeometry, sphereMaterial5 );
	vertexRoot.add(sphere5);
	sphere5.position.set(getVertex5()[0],getVertex5()[1],getVertex5()[2]);

    const lableDiv5 = document.createElement( 'div' );
    lableDiv5.className = 'label';
    lableDiv5.textContent = '5';
    lableDiv5.style.marginTop = '-1em';

    const vertexLabel5 = new CSS2DObject( lableDiv5 );
    vertexLabel5.position.set(getVertex5()[0],getVertex5()[1],getVertex5()[2]);
    vertexlabelRoot.add( vertexLabel5 );
            
            	const sphereMaterial6 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere6 = new THREE.Mesh( sphereGeometry, sphereMaterial6 );
	vertexRoot.add(sphere6);
	sphere6.position.set(getVertex6()[0],getVertex6()[1],getVertex6()[2]);

    const lableDiv6 = document.createElement( 'div' );
    lableDiv6.className = 'label';
    lableDiv6.textContent = '6';
    lableDiv6.style.marginTop = '-1em';

    const vertexLabel6 = new CSS2DObject( lableDiv6 );
    vertexLabel6.position.set(getVertex6()[0],getVertex6()[1],getVertex6()[2]);
    vertexlabelRoot.add( vertexLabel6 );
            
            	const sphereMaterial7 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere7 = new THREE.Mesh( sphereGeometry, sphereMaterial7 );
	vertexRoot.add(sphere7);
	sphere7.position.set(getVertex7()[0],getVertex7()[1],getVertex7()[2]);

    const lableDiv7 = document.createElement( 'div' );
    lableDiv7.className = 'label';
    lableDiv7.textContent = '7';
    lableDiv7.style.marginTop = '-1em';

    const vertexLabel7 = new CSS2DObject( lableDiv7 );
    vertexLabel7.position.set(getVertex7()[0],getVertex7()[1],getVertex7()[2]);
    vertexlabelRoot.add( vertexLabel7 );
            
            	const sphereMaterial8 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere8 = new THREE.Mesh( sphereGeometry, sphereMaterial8 );
	vertexRoot.add(sphere8);
	sphere8.position.set(getVertex8()[0],getVertex8()[1],getVertex8()[2]);

    const lableDiv8 = document.createElement( 'div' );
    lableDiv8.className = 'label';
    lableDiv8.textContent = '8';
    lableDiv8.style.marginTop = '-1em';

    const vertexLabel8 = new CSS2DObject( lableDiv8 );
    vertexLabel8.position.set(getVertex8()[0],getVertex8()[1],getVertex8()[2]);
    vertexlabelRoot.add( vertexLabel8 );
            
            	const sphereMaterial9 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere9 = new THREE.Mesh( sphereGeometry, sphereMaterial9 );
	vertexRoot.add(sphere9);
	sphere9.position.set(getVertex9()[0],getVertex9()[1],getVertex9()[2]);

    const lableDiv9 = document.createElement( 'div' );
    lableDiv9.className = 'label';
    lableDiv9.textContent = '9';
    lableDiv9.style.marginTop = '-1em';

    const vertexLabel9 = new CSS2DObject( lableDiv9 );
    vertexLabel9.position.set(getVertex9()[0],getVertex9()[1],getVertex9()[2]);
    vertexlabelRoot.add( vertexLabel9 );
            
            	const sphereMaterial10 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere10 = new THREE.Mesh( sphereGeometry, sphereMaterial10 );
	vertexRoot.add(sphere10);
	sphere10.position.set(getVertex10()[0],getVertex10()[1],getVertex10()[2]);

    const lableDiv10 = document.createElement( 'div' );
    lableDiv10.className = 'label';
    lableDiv10.textContent = '10';
    lableDiv10.style.marginTop = '-1em';

    const vertexLabel10 = new CSS2DObject( lableDiv10 );
    vertexLabel10.position.set(getVertex10()[0],getVertex10()[1],getVertex10()[2]);
    vertexlabelRoot.add( vertexLabel10 );
            
            	const sphereMaterial11 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere11 = new THREE.Mesh( sphereGeometry, sphereMaterial11 );
	vertexRoot.add(sphere11);
	sphere11.position.set(getVertex11()[0],getVertex11()[1],getVertex11()[2]);

    const lableDiv11 = document.createElement( 'div' );
    lableDiv11.className = 'label';
    lableDiv11.textContent = '11';
    lableDiv11.style.marginTop = '-1em';

    const vertexLabel11 = new CSS2DObject( lableDiv11 );
    vertexLabel11.position.set(getVertex11()[0],getVertex11()[1],getVertex11()[2]);
    vertexlabelRoot.add( vertexLabel11 );
            
            	const sphereMaterial12 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere12 = new THREE.Mesh( sphereGeometry, sphereMaterial12 );
	vertexRoot.add(sphere12);
	sphere12.position.set(getVertex12()[0],getVertex12()[1],getVertex12()[2]);

    const lableDiv12 = document.createElement( 'div' );
    lableDiv12.className = 'label';
    lableDiv12.textContent = '12';
    lableDiv12.style.marginTop = '-1em';

    const vertexLabel12 = new CSS2DObject( lableDiv12 );
    vertexLabel12.position.set(getVertex12()[0],getVertex12()[1],getVertex12()[2]);
    vertexlabelRoot.add( vertexLabel12 );
            
            	const sphereMaterial13 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere13 = new THREE.Mesh( sphereGeometry, sphereMaterial13 );
	vertexRoot.add(sphere13);
	sphere13.position.set(getVertex13()[0],getVertex13()[1],getVertex13()[2]);

    const lableDiv13 = document.createElement( 'div' );
    lableDiv13.className = 'label';
    lableDiv13.textContent = '13';
    lableDiv13.style.marginTop = '-1em';

    const vertexLabel13 = new CSS2DObject( lableDiv13 );
    vertexLabel13.position.set(getVertex13()[0],getVertex13()[1],getVertex13()[2]);
    vertexlabelRoot.add( vertexLabel13 );
            
            	const sphereMaterial14 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere14 = new THREE.Mesh( sphereGeometry, sphereMaterial14 );
	vertexRoot.add(sphere14);
	sphere14.position.set(getVertex14()[0],getVertex14()[1],getVertex14()[2]);

    const lableDiv14 = document.createElement( 'div' );
    lableDiv14.className = 'label';
    lableDiv14.textContent = '14';
    lableDiv14.style.marginTop = '-1em';

    const vertexLabel14 = new CSS2DObject( lableDiv14 );
    vertexLabel14.position.set(getVertex14()[0],getVertex14()[1],getVertex14()[2]);
    vertexlabelRoot.add( vertexLabel14 );
            
            	// generate the rings for the incircles 

	var inradius9 = calulateInradius(getVertex1(), getVertex2(), getVertex7());
	var incenter9 = calulateIncenter(getVertex1(), getVertex2(), getVertex7());
	var ringGeometry9 = new THREE.RingGeometry((inradius9 - 0.005),inradius9, 32);
	const ringMaterial9 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh9 = new THREE.Mesh(ringGeometry9, ringMaterial9);

	function setCircleRotation9(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,1,0],[1.4831632475943928,0.,1.0487547899806575]);

        ringMesh9.position.setX(incenter[0]);
        ringMesh9.position.setY(incenter[1]);
        ringMesh9.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex2(), getVertex7());
        var relRadius = inradius/inradius9;

        ringMesh9.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A9 = new THREE.Vector3(0,0,1.4142135623730951);
        const B9 = new THREE.Vector3(1,1,0);
        const C9 = new THREE.Vector3(1.4831632475943928,0.,1.0487547899806575);

        const normalVec9 = new THREE.Vector3();
        normalVec9.crossVectors(B9.sub(A9), C9.sub(A9));
        normalVec9.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal9 = new THREE.Vector3(0,0,1);

        const quaternionRotation9 = new THREE.Quaternion();
        quaternionRotation9.setFromUnitVectors(initialNormal9, normalVec9);

        ringMesh9.setRotationFromQuaternion(quaternionRotation9);

        return quaternionRotation9;
    }

    ringRoot.add(ringMesh9);
            
	var inradius10 = calulateInradius(getVertex1(), getVertex3(), getVertex7());
	var incenter10 = calulateIncenter(getVertex1(), getVertex3(), getVertex7());
	var ringGeometry10 = new THREE.RingGeometry((inradius10 - 0.005),inradius10, 32);
	const ringMaterial10 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh10 = new THREE.Mesh(ringGeometry10, ringMaterial10);

	function setCircleRotation10(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,-1,0],[1.4831632475943928,0.,1.0487547899806575]);

        ringMesh10.position.setX(incenter[0]);
        ringMesh10.position.setY(incenter[1]);
        ringMesh10.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex3(), getVertex7());
        var relRadius = inradius/inradius10;

        ringMesh10.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A10 = new THREE.Vector3(0,0,1.4142135623730951);
        const B10 = new THREE.Vector3(1,-1,0);
        const C10 = new THREE.Vector3(1.4831632475943928,0.,1.0487547899806575);

        const normalVec10 = new THREE.Vector3();
        normalVec10.crossVectors(B10.sub(A10), C10.sub(A10));
        normalVec10.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal10 = new THREE.Vector3(0,0,1);

        const quaternionRotation10 = new THREE.Quaternion();
        quaternionRotation10.setFromUnitVectors(initialNormal10, normalVec10);

        ringMesh10.setRotationFromQuaternion(quaternionRotation10);

        return quaternionRotation10;
    }

    ringRoot.add(ringMesh10);
            
	var inradius11 = calulateInradius(getVertex2(), getVertex3(), getVertex7());
	var incenter11 = calulateIncenter(getVertex2(), getVertex3(), getVertex7());
	var ringGeometry11 = new THREE.RingGeometry((inradius11 - 0.005),inradius11, 32);
	const ringMaterial11 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh11 = new THREE.Mesh(ringGeometry11, ringMaterial11);

	function setCircleRotation11(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,1,0],[ 1,-1,0],[1.4831632475943928,0.,1.0487547899806575]);

        ringMesh11.position.setX(incenter[0]);
        ringMesh11.position.setY(incenter[1]);
        ringMesh11.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex3(), getVertex7());
        var relRadius = inradius/inradius11;

        ringMesh11.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A11 = new THREE.Vector3(1,1,0);
        const B11 = new THREE.Vector3(1,-1,0);
        const C11 = new THREE.Vector3(1.4831632475943928,0.,1.0487547899806575);

        const normalVec11 = new THREE.Vector3();
        normalVec11.crossVectors(B11.sub(A11), C11.sub(A11));
        normalVec11.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal11 = new THREE.Vector3(0,0,1);

        const quaternionRotation11 = new THREE.Quaternion();
        quaternionRotation11.setFromUnitVectors(initialNormal11, normalVec11);

        ringMesh11.setRotationFromQuaternion(quaternionRotation11);

        return quaternionRotation11;
    }

    ringRoot.add(ringMesh11);
            
	var inradius12 = calulateInradius(getVertex2(), getVertex5(), getVertex8());
	var incenter12 = calulateIncenter(getVertex2(), getVertex5(), getVertex8());
	var ringGeometry12 = new THREE.RingGeometry((inradius12 - 0.005),inradius12, 32);
	const ringMaterial12 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh12 = new THREE.Mesh(ringGeometry12, ringMaterial12);

	function setCircleRotation12(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,1,0],[ -1,1,0],[0.,1.4831632475943928,-1.0487547899806575]);

        ringMesh12.position.setX(incenter[0]);
        ringMesh12.position.setY(incenter[1]);
        ringMesh12.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex5(), getVertex8());
        var relRadius = inradius/inradius12;

        ringMesh12.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A12 = new THREE.Vector3(1,1,0);
        const B12 = new THREE.Vector3(-1,1,0);
        const C12 = new THREE.Vector3(0.,1.4831632475943928,-1.0487547899806575);

        const normalVec12 = new THREE.Vector3();
        normalVec12.crossVectors(B12.sub(A12), C12.sub(A12));
        normalVec12.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal12 = new THREE.Vector3(0,0,1);

        const quaternionRotation12 = new THREE.Quaternion();
        quaternionRotation12.setFromUnitVectors(initialNormal12, normalVec12);

        ringMesh12.setRotationFromQuaternion(quaternionRotation12);

        return quaternionRotation12;
    }

    ringRoot.add(ringMesh12);
            
	var inradius13 = calulateInradius(getVertex2(), getVertex6(), getVertex8());
	var incenter13 = calulateIncenter(getVertex2(), getVertex6(), getVertex8());
	var ringGeometry13 = new THREE.RingGeometry((inradius13 - 0.005),inradius13, 32);
	const ringMaterial13 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh13 = new THREE.Mesh(ringGeometry13, ringMaterial13);

	function setCircleRotation13(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,1,0],[ 0,0,-1.4142135623730951],[0.,1.4831632475943928,-1.0487547899806575]);

        ringMesh13.position.setX(incenter[0]);
        ringMesh13.position.setY(incenter[1]);
        ringMesh13.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex6(), getVertex8());
        var relRadius = inradius/inradius13;

        ringMesh13.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A13 = new THREE.Vector3(1,1,0);
        const B13 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C13 = new THREE.Vector3(0.,1.4831632475943928,-1.0487547899806575);

        const normalVec13 = new THREE.Vector3();
        normalVec13.crossVectors(B13.sub(A13), C13.sub(A13));
        normalVec13.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal13 = new THREE.Vector3(0,0,1);

        const quaternionRotation13 = new THREE.Quaternion();
        quaternionRotation13.setFromUnitVectors(initialNormal13, normalVec13);

        ringMesh13.setRotationFromQuaternion(quaternionRotation13);

        return quaternionRotation13;
    }

    ringRoot.add(ringMesh13);
            
	var inradius14 = calulateInradius(getVertex5(), getVertex6(), getVertex8());
	var incenter14 = calulateIncenter(getVertex5(), getVertex6(), getVertex8());
	var ringGeometry14 = new THREE.RingGeometry((inradius14 - 0.005),inradius14, 32);
	const ringMaterial14 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh14 = new THREE.Mesh(ringGeometry14, ringMaterial14);

	function setCircleRotation14(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1,1,0],[ 0,0,-1.4142135623730951],[0.,1.4831632475943928,-1.0487547899806575]);

        ringMesh14.position.setX(incenter[0]);
        ringMesh14.position.setY(incenter[1]);
        ringMesh14.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex5(), getVertex6(), getVertex8());
        var relRadius = inradius/inradius14;

        ringMesh14.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A14 = new THREE.Vector3(-1,1,0);
        const B14 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C14 = new THREE.Vector3(0.,1.4831632475943928,-1.0487547899806575);

        const normalVec14 = new THREE.Vector3();
        normalVec14.crossVectors(B14.sub(A14), C14.sub(A14));
        normalVec14.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal14 = new THREE.Vector3(0,0,1);

        const quaternionRotation14 = new THREE.Quaternion();
        quaternionRotation14.setFromUnitVectors(initialNormal14, normalVec14);

        ringMesh14.setRotationFromQuaternion(quaternionRotation14);

        return quaternionRotation14;
    }

    ringRoot.add(ringMesh14);
            
	var inradius15 = calulateInradius(getVertex1(), getVertex2(), getVertex9());
	var incenter15 = calulateIncenter(getVertex1(), getVertex2(), getVertex9());
	var ringGeometry15 = new THREE.RingGeometry((inradius15 - 0.005),inradius15, 32);
	const ringMaterial15 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh15 = new THREE.Mesh(ringGeometry15, ringMaterial15);

	function setCircleRotation15(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,1,0],[0.,1.4831632475943928,1.0487547899806575]);

        ringMesh15.position.setX(incenter[0]);
        ringMesh15.position.setY(incenter[1]);
        ringMesh15.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex2(), getVertex9());
        var relRadius = inradius/inradius15;

        ringMesh15.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A15 = new THREE.Vector3(0,0,1.4142135623730951);
        const B15 = new THREE.Vector3(1,1,0);
        const C15 = new THREE.Vector3(0.,1.4831632475943928,1.0487547899806575);

        const normalVec15 = new THREE.Vector3();
        normalVec15.crossVectors(B15.sub(A15), C15.sub(A15));
        normalVec15.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal15 = new THREE.Vector3(0,0,1);

        const quaternionRotation15 = new THREE.Quaternion();
        quaternionRotation15.setFromUnitVectors(initialNormal15, normalVec15);

        ringMesh15.setRotationFromQuaternion(quaternionRotation15);

        return quaternionRotation15;
    }

    ringRoot.add(ringMesh15);
            
	var inradius16 = calulateInradius(getVertex1(), getVertex5(), getVertex9());
	var incenter16 = calulateIncenter(getVertex1(), getVertex5(), getVertex9());
	var ringGeometry16 = new THREE.RingGeometry((inradius16 - 0.005),inradius16, 32);
	const ringMaterial16 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh16 = new THREE.Mesh(ringGeometry16, ringMaterial16);

	function setCircleRotation16(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,1,0],[0.,1.4831632475943928,1.0487547899806575]);

        ringMesh16.position.setX(incenter[0]);
        ringMesh16.position.setY(incenter[1]);
        ringMesh16.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex5(), getVertex9());
        var relRadius = inradius/inradius16;

        ringMesh16.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A16 = new THREE.Vector3(0,0,1.4142135623730951);
        const B16 = new THREE.Vector3(-1,1,0);
        const C16 = new THREE.Vector3(0.,1.4831632475943928,1.0487547899806575);

        const normalVec16 = new THREE.Vector3();
        normalVec16.crossVectors(B16.sub(A16), C16.sub(A16));
        normalVec16.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal16 = new THREE.Vector3(0,0,1);

        const quaternionRotation16 = new THREE.Quaternion();
        quaternionRotation16.setFromUnitVectors(initialNormal16, normalVec16);

        ringMesh16.setRotationFromQuaternion(quaternionRotation16);

        return quaternionRotation16;
    }

    ringRoot.add(ringMesh16);
            
	var inradius17 = calulateInradius(getVertex2(), getVertex5(), getVertex9());
	var incenter17 = calulateIncenter(getVertex2(), getVertex5(), getVertex9());
	var ringGeometry17 = new THREE.RingGeometry((inradius17 - 0.005),inradius17, 32);
	const ringMaterial17 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh17 = new THREE.Mesh(ringGeometry17, ringMaterial17);

	function setCircleRotation17(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,1,0],[ -1,1,0],[0.,1.4831632475943928,1.0487547899806575]);

        ringMesh17.position.setX(incenter[0]);
        ringMesh17.position.setY(incenter[1]);
        ringMesh17.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex5(), getVertex9());
        var relRadius = inradius/inradius17;

        ringMesh17.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A17 = new THREE.Vector3(1,1,0);
        const B17 = new THREE.Vector3(-1,1,0);
        const C17 = new THREE.Vector3(0.,1.4831632475943928,1.0487547899806575);

        const normalVec17 = new THREE.Vector3();
        normalVec17.crossVectors(B17.sub(A17), C17.sub(A17));
        normalVec17.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal17 = new THREE.Vector3(0,0,1);

        const quaternionRotation17 = new THREE.Quaternion();
        quaternionRotation17.setFromUnitVectors(initialNormal17, normalVec17);

        ringMesh17.setRotationFromQuaternion(quaternionRotation17);

        return quaternionRotation17;
    }

    ringRoot.add(ringMesh17);
            
	var inradius18 = calulateInradius(getVertex2(), getVertex3(), getVertex10());
	var incenter18 = calulateIncenter(getVertex2(), getVertex3(), getVertex10());
	var ringGeometry18 = new THREE.RingGeometry((inradius18 - 0.005),inradius18, 32);
	const ringMaterial18 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh18 = new THREE.Mesh(ringGeometry18, ringMaterial18);

	function setCircleRotation18(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,1,0],[ 1,-1,0],[1.4831632475943928,0.,-1.0487547899806575]);

        ringMesh18.position.setX(incenter[0]);
        ringMesh18.position.setY(incenter[1]);
        ringMesh18.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex3(), getVertex10());
        var relRadius = inradius/inradius18;

        ringMesh18.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A18 = new THREE.Vector3(1,1,0);
        const B18 = new THREE.Vector3(1,-1,0);
        const C18 = new THREE.Vector3(1.4831632475943928,0.,-1.0487547899806575);

        const normalVec18 = new THREE.Vector3();
        normalVec18.crossVectors(B18.sub(A18), C18.sub(A18));
        normalVec18.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal18 = new THREE.Vector3(0,0,1);

        const quaternionRotation18 = new THREE.Quaternion();
        quaternionRotation18.setFromUnitVectors(initialNormal18, normalVec18);

        ringMesh18.setRotationFromQuaternion(quaternionRotation18);

        return quaternionRotation18;
    }

    ringRoot.add(ringMesh18);
            
	var inradius19 = calulateInradius(getVertex2(), getVertex6(), getVertex10());
	var incenter19 = calulateIncenter(getVertex2(), getVertex6(), getVertex10());
	var ringGeometry19 = new THREE.RingGeometry((inradius19 - 0.005),inradius19, 32);
	const ringMaterial19 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh19 = new THREE.Mesh(ringGeometry19, ringMaterial19);

	function setCircleRotation19(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,1,0],[ 0,0,-1.4142135623730951],[1.4831632475943928,0.,-1.0487547899806575]);

        ringMesh19.position.setX(incenter[0]);
        ringMesh19.position.setY(incenter[1]);
        ringMesh19.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex6(), getVertex10());
        var relRadius = inradius/inradius19;

        ringMesh19.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A19 = new THREE.Vector3(1,1,0);
        const B19 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C19 = new THREE.Vector3(1.4831632475943928,0.,-1.0487547899806575);

        const normalVec19 = new THREE.Vector3();
        normalVec19.crossVectors(B19.sub(A19), C19.sub(A19));
        normalVec19.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal19 = new THREE.Vector3(0,0,1);

        const quaternionRotation19 = new THREE.Quaternion();
        quaternionRotation19.setFromUnitVectors(initialNormal19, normalVec19);

        ringMesh19.setRotationFromQuaternion(quaternionRotation19);

        return quaternionRotation19;
    }

    ringRoot.add(ringMesh19);
            
	var inradius20 = calulateInradius(getVertex3(), getVertex6(), getVertex10());
	var incenter20 = calulateIncenter(getVertex3(), getVertex6(), getVertex10());
	var ringGeometry20 = new THREE.RingGeometry((inradius20 - 0.005),inradius20, 32);
	const ringMaterial20 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh20 = new THREE.Mesh(ringGeometry20, ringMaterial20);

	function setCircleRotation20(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,-1,0],[ 0,0,-1.4142135623730951],[1.4831632475943928,0.,-1.0487547899806575]);

        ringMesh20.position.setX(incenter[0]);
        ringMesh20.position.setY(incenter[1]);
        ringMesh20.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex6(), getVertex10());
        var relRadius = inradius/inradius20;

        ringMesh20.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A20 = new THREE.Vector3(1,-1,0);
        const B20 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C20 = new THREE.Vector3(1.4831632475943928,0.,-1.0487547899806575);

        const normalVec20 = new THREE.Vector3();
        normalVec20.crossVectors(B20.sub(A20), C20.sub(A20));
        normalVec20.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal20 = new THREE.Vector3(0,0,1);

        const quaternionRotation20 = new THREE.Quaternion();
        quaternionRotation20.setFromUnitVectors(initialNormal20, normalVec20);

        ringMesh20.setRotationFromQuaternion(quaternionRotation20);

        return quaternionRotation20;
    }

    ringRoot.add(ringMesh20);
            
	var inradius21 = calulateInradius(getVertex1(), getVertex4(), getVertex11());
	var incenter21 = calulateIncenter(getVertex1(), getVertex4(), getVertex11());
	var ringGeometry21 = new THREE.RingGeometry((inradius21 - 0.005),inradius21, 32);
	const ringMaterial21 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh21 = new THREE.Mesh(ringGeometry21, ringMaterial21);

	function setCircleRotation21(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,-1,0],[-1.4831632475943928,0.,1.0487547899806575]);

        ringMesh21.position.setX(incenter[0]);
        ringMesh21.position.setY(incenter[1]);
        ringMesh21.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex4(), getVertex11());
        var relRadius = inradius/inradius21;

        ringMesh21.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A21 = new THREE.Vector3(0,0,1.4142135623730951);
        const B21 = new THREE.Vector3(-1,-1,0);
        const C21 = new THREE.Vector3(-1.4831632475943928,0.,1.0487547899806575);

        const normalVec21 = new THREE.Vector3();
        normalVec21.crossVectors(B21.sub(A21), C21.sub(A21));
        normalVec21.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal21 = new THREE.Vector3(0,0,1);

        const quaternionRotation21 = new THREE.Quaternion();
        quaternionRotation21.setFromUnitVectors(initialNormal21, normalVec21);

        ringMesh21.setRotationFromQuaternion(quaternionRotation21);

        return quaternionRotation21;
    }

    ringRoot.add(ringMesh21);
            
	var inradius22 = calulateInradius(getVertex1(), getVertex5(), getVertex11());
	var incenter22 = calulateIncenter(getVertex1(), getVertex5(), getVertex11());
	var ringGeometry22 = new THREE.RingGeometry((inradius22 - 0.005),inradius22, 32);
	const ringMaterial22 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh22 = new THREE.Mesh(ringGeometry22, ringMaterial22);

	function setCircleRotation22(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,1,0],[-1.4831632475943928,0.,1.0487547899806575]);

        ringMesh22.position.setX(incenter[0]);
        ringMesh22.position.setY(incenter[1]);
        ringMesh22.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex5(), getVertex11());
        var relRadius = inradius/inradius22;

        ringMesh22.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A22 = new THREE.Vector3(0,0,1.4142135623730951);
        const B22 = new THREE.Vector3(-1,1,0);
        const C22 = new THREE.Vector3(-1.4831632475943928,0.,1.0487547899806575);

        const normalVec22 = new THREE.Vector3();
        normalVec22.crossVectors(B22.sub(A22), C22.sub(A22));
        normalVec22.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal22 = new THREE.Vector3(0,0,1);

        const quaternionRotation22 = new THREE.Quaternion();
        quaternionRotation22.setFromUnitVectors(initialNormal22, normalVec22);

        ringMesh22.setRotationFromQuaternion(quaternionRotation22);

        return quaternionRotation22;
    }

    ringRoot.add(ringMesh22);
            
	var inradius23 = calulateInradius(getVertex4(), getVertex5(), getVertex11());
	var incenter23 = calulateIncenter(getVertex4(), getVertex5(), getVertex11());
	var ringGeometry23 = new THREE.RingGeometry((inradius23 - 0.005),inradius23, 32);
	const ringMaterial23 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh23 = new THREE.Mesh(ringGeometry23, ringMaterial23);

	function setCircleRotation23(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1,-1,0],[ -1,1,0],[-1.4831632475943928,0.,1.0487547899806575]);

        ringMesh23.position.setX(incenter[0]);
        ringMesh23.position.setY(incenter[1]);
        ringMesh23.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex5(), getVertex11());
        var relRadius = inradius/inradius23;

        ringMesh23.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A23 = new THREE.Vector3(-1,-1,0);
        const B23 = new THREE.Vector3(-1,1,0);
        const C23 = new THREE.Vector3(-1.4831632475943928,0.,1.0487547899806575);

        const normalVec23 = new THREE.Vector3();
        normalVec23.crossVectors(B23.sub(A23), C23.sub(A23));
        normalVec23.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal23 = new THREE.Vector3(0,0,1);

        const quaternionRotation23 = new THREE.Quaternion();
        quaternionRotation23.setFromUnitVectors(initialNormal23, normalVec23);

        ringMesh23.setRotationFromQuaternion(quaternionRotation23);

        return quaternionRotation23;
    }

    ringRoot.add(ringMesh23);
            
	var inradius24 = calulateInradius(getVertex3(), getVertex4(), getVertex12());
	var incenter24 = calulateIncenter(getVertex3(), getVertex4(), getVertex12());
	var ringGeometry24 = new THREE.RingGeometry((inradius24 - 0.005),inradius24, 32);
	const ringMaterial24 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh24 = new THREE.Mesh(ringGeometry24, ringMaterial24);

	function setCircleRotation24(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,-1,0],[ -1,-1,0],[0.,-1.4831632475943928,-1.0487547899806575]);

        ringMesh24.position.setX(incenter[0]);
        ringMesh24.position.setY(incenter[1]);
        ringMesh24.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex4(), getVertex12());
        var relRadius = inradius/inradius24;

        ringMesh24.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A24 = new THREE.Vector3(1,-1,0);
        const B24 = new THREE.Vector3(-1,-1,0);
        const C24 = new THREE.Vector3(0.,-1.4831632475943928,-1.0487547899806575);

        const normalVec24 = new THREE.Vector3();
        normalVec24.crossVectors(B24.sub(A24), C24.sub(A24));
        normalVec24.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal24 = new THREE.Vector3(0,0,1);

        const quaternionRotation24 = new THREE.Quaternion();
        quaternionRotation24.setFromUnitVectors(initialNormal24, normalVec24);

        ringMesh24.setRotationFromQuaternion(quaternionRotation24);

        return quaternionRotation24;
    }

    ringRoot.add(ringMesh24);
            
	var inradius25 = calulateInradius(getVertex3(), getVertex6(), getVertex12());
	var incenter25 = calulateIncenter(getVertex3(), getVertex6(), getVertex12());
	var ringGeometry25 = new THREE.RingGeometry((inradius25 - 0.005),inradius25, 32);
	const ringMaterial25 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh25 = new THREE.Mesh(ringGeometry25, ringMaterial25);

	function setCircleRotation25(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,-1,0],[ 0,0,-1.4142135623730951],[0.,-1.4831632475943928,-1.0487547899806575]);

        ringMesh25.position.setX(incenter[0]);
        ringMesh25.position.setY(incenter[1]);
        ringMesh25.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex6(), getVertex12());
        var relRadius = inradius/inradius25;

        ringMesh25.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A25 = new THREE.Vector3(1,-1,0);
        const B25 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C25 = new THREE.Vector3(0.,-1.4831632475943928,-1.0487547899806575);

        const normalVec25 = new THREE.Vector3();
        normalVec25.crossVectors(B25.sub(A25), C25.sub(A25));
        normalVec25.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal25 = new THREE.Vector3(0,0,1);

        const quaternionRotation25 = new THREE.Quaternion();
        quaternionRotation25.setFromUnitVectors(initialNormal25, normalVec25);

        ringMesh25.setRotationFromQuaternion(quaternionRotation25);

        return quaternionRotation25;
    }

    ringRoot.add(ringMesh25);
            
	var inradius26 = calulateInradius(getVertex4(), getVertex6(), getVertex12());
	var incenter26 = calulateIncenter(getVertex4(), getVertex6(), getVertex12());
	var ringGeometry26 = new THREE.RingGeometry((inradius26 - 0.005),inradius26, 32);
	const ringMaterial26 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh26 = new THREE.Mesh(ringGeometry26, ringMaterial26);

	function setCircleRotation26(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1,-1,0],[ 0,0,-1.4142135623730951],[0.,-1.4831632475943928,-1.0487547899806575]);

        ringMesh26.position.setX(incenter[0]);
        ringMesh26.position.setY(incenter[1]);
        ringMesh26.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex6(), getVertex12());
        var relRadius = inradius/inradius26;

        ringMesh26.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A26 = new THREE.Vector3(-1,-1,0);
        const B26 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C26 = new THREE.Vector3(0.,-1.4831632475943928,-1.0487547899806575);

        const normalVec26 = new THREE.Vector3();
        normalVec26.crossVectors(B26.sub(A26), C26.sub(A26));
        normalVec26.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal26 = new THREE.Vector3(0,0,1);

        const quaternionRotation26 = new THREE.Quaternion();
        quaternionRotation26.setFromUnitVectors(initialNormal26, normalVec26);

        ringMesh26.setRotationFromQuaternion(quaternionRotation26);

        return quaternionRotation26;
    }

    ringRoot.add(ringMesh26);
            
	var inradius27 = calulateInradius(getVertex1(), getVertex3(), getVertex13());
	var incenter27 = calulateIncenter(getVertex1(), getVertex3(), getVertex13());
	var ringGeometry27 = new THREE.RingGeometry((inradius27 - 0.005),inradius27, 32);
	const ringMaterial27 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh27 = new THREE.Mesh(ringGeometry27, ringMaterial27);

	function setCircleRotation27(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,-1,0],[0.,-1.4831632475943928,1.0487547899806575]);

        ringMesh27.position.setX(incenter[0]);
        ringMesh27.position.setY(incenter[1]);
        ringMesh27.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex3(), getVertex13());
        var relRadius = inradius/inradius27;

        ringMesh27.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A27 = new THREE.Vector3(0,0,1.4142135623730951);
        const B27 = new THREE.Vector3(1,-1,0);
        const C27 = new THREE.Vector3(0.,-1.4831632475943928,1.0487547899806575);

        const normalVec27 = new THREE.Vector3();
        normalVec27.crossVectors(B27.sub(A27), C27.sub(A27));
        normalVec27.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal27 = new THREE.Vector3(0,0,1);

        const quaternionRotation27 = new THREE.Quaternion();
        quaternionRotation27.setFromUnitVectors(initialNormal27, normalVec27);

        ringMesh27.setRotationFromQuaternion(quaternionRotation27);

        return quaternionRotation27;
    }

    ringRoot.add(ringMesh27);
            
	var inradius28 = calulateInradius(getVertex1(), getVertex4(), getVertex13());
	var incenter28 = calulateIncenter(getVertex1(), getVertex4(), getVertex13());
	var ringGeometry28 = new THREE.RingGeometry((inradius28 - 0.005),inradius28, 32);
	const ringMaterial28 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh28 = new THREE.Mesh(ringGeometry28, ringMaterial28);

	function setCircleRotation28(){

        //translate ring to incenter
        var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,-1,0],[0.,-1.4831632475943928,1.0487547899806575]);

        ringMesh28.position.setX(incenter[0]);
        ringMesh28.position.setY(incenter[1]);
        ringMesh28.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex4(), getVertex13());
        var relRadius = inradius/inradius28;

        ringMesh28.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A28 = new THREE.Vector3(0,0,1.4142135623730951);
        const B28 = new THREE.Vector3(-1,-1,0);
        const C28 = new THREE.Vector3(0.,-1.4831632475943928,1.0487547899806575);

        const normalVec28 = new THREE.Vector3();
        normalVec28.crossVectors(B28.sub(A28), C28.sub(A28));
        normalVec28.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal28 = new THREE.Vector3(0,0,1);

        const quaternionRotation28 = new THREE.Quaternion();
        quaternionRotation28.setFromUnitVectors(initialNormal28, normalVec28);

        ringMesh28.setRotationFromQuaternion(quaternionRotation28);

        return quaternionRotation28;
    }

    ringRoot.add(ringMesh28);
            
	var inradius29 = calulateInradius(getVertex3(), getVertex4(), getVertex13());
	var incenter29 = calulateIncenter(getVertex3(), getVertex4(), getVertex13());
	var ringGeometry29 = new THREE.RingGeometry((inradius29 - 0.005),inradius29, 32);
	const ringMaterial29 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh29 = new THREE.Mesh(ringGeometry29, ringMaterial29);

	function setCircleRotation29(){

        //translate ring to incenter
        var incenter = calulateIncenter([1,-1,0],[ -1,-1,0],[0.,-1.4831632475943928,1.0487547899806575]);

        ringMesh29.position.setX(incenter[0]);
        ringMesh29.position.setY(incenter[1]);
        ringMesh29.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex4(), getVertex13());
        var relRadius = inradius/inradius29;

        ringMesh29.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A29 = new THREE.Vector3(1,-1,0);
        const B29 = new THREE.Vector3(-1,-1,0);
        const C29 = new THREE.Vector3(0.,-1.4831632475943928,1.0487547899806575);

        const normalVec29 = new THREE.Vector3();
        normalVec29.crossVectors(B29.sub(A29), C29.sub(A29));
        normalVec29.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal29 = new THREE.Vector3(0,0,1);

        const quaternionRotation29 = new THREE.Quaternion();
        quaternionRotation29.setFromUnitVectors(initialNormal29, normalVec29);

        ringMesh29.setRotationFromQuaternion(quaternionRotation29);

        return quaternionRotation29;
    }

    ringRoot.add(ringMesh29);
            
	var inradius30 = calulateInradius(getVertex4(), getVertex5(), getVertex14());
	var incenter30 = calulateIncenter(getVertex4(), getVertex5(), getVertex14());
	var ringGeometry30 = new THREE.RingGeometry((inradius30 - 0.005),inradius30, 32);
	const ringMaterial30 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh30 = new THREE.Mesh(ringGeometry30, ringMaterial30);

	function setCircleRotation30(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1,-1,0],[ -1,1,0],[-1.4831632475943928,0.,-1.0487547899806575]);

        ringMesh30.position.setX(incenter[0]);
        ringMesh30.position.setY(incenter[1]);
        ringMesh30.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex5(), getVertex14());
        var relRadius = inradius/inradius30;

        ringMesh30.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A30 = new THREE.Vector3(-1,-1,0);
        const B30 = new THREE.Vector3(-1,1,0);
        const C30 = new THREE.Vector3(-1.4831632475943928,0.,-1.0487547899806575);

        const normalVec30 = new THREE.Vector3();
        normalVec30.crossVectors(B30.sub(A30), C30.sub(A30));
        normalVec30.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal30 = new THREE.Vector3(0,0,1);

        const quaternionRotation30 = new THREE.Quaternion();
        quaternionRotation30.setFromUnitVectors(initialNormal30, normalVec30);

        ringMesh30.setRotationFromQuaternion(quaternionRotation30);

        return quaternionRotation30;
    }

    ringRoot.add(ringMesh30);
            
	var inradius31 = calulateInradius(getVertex4(), getVertex6(), getVertex14());
	var incenter31 = calulateIncenter(getVertex4(), getVertex6(), getVertex14());
	var ringGeometry31 = new THREE.RingGeometry((inradius31 - 0.005),inradius31, 32);
	const ringMaterial31 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh31 = new THREE.Mesh(ringGeometry31, ringMaterial31);

	function setCircleRotation31(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1,-1,0],[ 0,0,-1.4142135623730951],[-1.4831632475943928,0.,-1.0487547899806575]);

        ringMesh31.position.setX(incenter[0]);
        ringMesh31.position.setY(incenter[1]);
        ringMesh31.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex6(), getVertex14());
        var relRadius = inradius/inradius31;

        ringMesh31.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A31 = new THREE.Vector3(-1,-1,0);
        const B31 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C31 = new THREE.Vector3(-1.4831632475943928,0.,-1.0487547899806575);

        const normalVec31 = new THREE.Vector3();
        normalVec31.crossVectors(B31.sub(A31), C31.sub(A31));
        normalVec31.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal31 = new THREE.Vector3(0,0,1);

        const quaternionRotation31 = new THREE.Quaternion();
        quaternionRotation31.setFromUnitVectors(initialNormal31, normalVec31);

        ringMesh31.setRotationFromQuaternion(quaternionRotation31);

        return quaternionRotation31;
    }

    ringRoot.add(ringMesh31);
            
	var inradius32 = calulateInradius(getVertex5(), getVertex6(), getVertex14());
	var incenter32 = calulateIncenter(getVertex5(), getVertex6(), getVertex14());
	var ringGeometry32 = new THREE.RingGeometry((inradius32 - 0.005),inradius32, 32);
	const ringMaterial32 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh32 = new THREE.Mesh(ringGeometry32, ringMaterial32);

	function setCircleRotation32(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1,1,0],[ 0,0,-1.4142135623730951],[-1.4831632475943928,0.,-1.0487547899806575]);

        ringMesh32.position.setX(incenter[0]);
        ringMesh32.position.setY(incenter[1]);
        ringMesh32.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex5(), getVertex6(), getVertex14());
        var relRadius = inradius/inradius32;

        ringMesh32.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A32 = new THREE.Vector3(-1,1,0);
        const B32 = new THREE.Vector3(0,0,-1.4142135623730951);
        const C32 = new THREE.Vector3(-1.4831632475943928,0.,-1.0487547899806575);

        const normalVec32 = new THREE.Vector3();
        normalVec32.crossVectors(B32.sub(A32), C32.sub(A32));
        normalVec32.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal32 = new THREE.Vector3(0,0,1);

        const quaternionRotation32 = new THREE.Quaternion();
        quaternionRotation32.setFromUnitVectors(initialNormal32, normalVec32);

        ringMesh32.setRotationFromQuaternion(quaternionRotation32);

        return quaternionRotation32;
    }

    ringRoot.add(ringMesh32);
            	// function to update the circles every frame 
	function updateCircles(){
		setCircleRotation9();
		setCircleRotation10();
		setCircleRotation11();
		setCircleRotation12();
		setCircleRotation13();
		setCircleRotation14();
		setCircleRotation15();
		setCircleRotation16();
		setCircleRotation17();
		setCircleRotation18();
		setCircleRotation19();
		setCircleRotation20();
		setCircleRotation21();
		setCircleRotation22();
		setCircleRotation23();
		setCircleRotation24();
		setCircleRotation25();
		setCircleRotation26();
		setCircleRotation27();
		setCircleRotation28();
		setCircleRotation29();
		setCircleRotation30();
		setCircleRotation31();
		setCircleRotation32();
	}

	// needs to be called once to be initialized 
	updateCircles();

	// function to update the circles width, that is called every frame even if the surface is not parameterized 
	function updateCircleWidth(){
		ringGeometry9.dispose();
		ringGeometry9 = new THREE.RingGeometry((inradius9 - guiParameters.circleWidth),inradius9, 32);
		ringMesh9.geometry = ringGeometry9; 
		ringGeometry10.dispose();
		ringGeometry10 = new THREE.RingGeometry((inradius10 - guiParameters.circleWidth),inradius10, 32);
		ringMesh10.geometry = ringGeometry10; 
		ringGeometry11.dispose();
		ringGeometry11 = new THREE.RingGeometry((inradius11 - guiParameters.circleWidth),inradius11, 32);
		ringMesh11.geometry = ringGeometry11; 
		ringGeometry12.dispose();
		ringGeometry12 = new THREE.RingGeometry((inradius12 - guiParameters.circleWidth),inradius12, 32);
		ringMesh12.geometry = ringGeometry12; 
		ringGeometry13.dispose();
		ringGeometry13 = new THREE.RingGeometry((inradius13 - guiParameters.circleWidth),inradius13, 32);
		ringMesh13.geometry = ringGeometry13; 
		ringGeometry14.dispose();
		ringGeometry14 = new THREE.RingGeometry((inradius14 - guiParameters.circleWidth),inradius14, 32);
		ringMesh14.geometry = ringGeometry14; 
		ringGeometry15.dispose();
		ringGeometry15 = new THREE.RingGeometry((inradius15 - guiParameters.circleWidth),inradius15, 32);
		ringMesh15.geometry = ringGeometry15; 
		ringGeometry16.dispose();
		ringGeometry16 = new THREE.RingGeometry((inradius16 - guiParameters.circleWidth),inradius16, 32);
		ringMesh16.geometry = ringGeometry16; 
		ringGeometry17.dispose();
		ringGeometry17 = new THREE.RingGeometry((inradius17 - guiParameters.circleWidth),inradius17, 32);
		ringMesh17.geometry = ringGeometry17; 
		ringGeometry18.dispose();
		ringGeometry18 = new THREE.RingGeometry((inradius18 - guiParameters.circleWidth),inradius18, 32);
		ringMesh18.geometry = ringGeometry18; 
		ringGeometry19.dispose();
		ringGeometry19 = new THREE.RingGeometry((inradius19 - guiParameters.circleWidth),inradius19, 32);
		ringMesh19.geometry = ringGeometry19; 
		ringGeometry20.dispose();
		ringGeometry20 = new THREE.RingGeometry((inradius20 - guiParameters.circleWidth),inradius20, 32);
		ringMesh20.geometry = ringGeometry20; 
		ringGeometry21.dispose();
		ringGeometry21 = new THREE.RingGeometry((inradius21 - guiParameters.circleWidth),inradius21, 32);
		ringMesh21.geometry = ringGeometry21; 
		ringGeometry22.dispose();
		ringGeometry22 = new THREE.RingGeometry((inradius22 - guiParameters.circleWidth),inradius22, 32);
		ringMesh22.geometry = ringGeometry22; 
		ringGeometry23.dispose();
		ringGeometry23 = new THREE.RingGeometry((inradius23 - guiParameters.circleWidth),inradius23, 32);
		ringMesh23.geometry = ringGeometry23; 
		ringGeometry24.dispose();
		ringGeometry24 = new THREE.RingGeometry((inradius24 - guiParameters.circleWidth),inradius24, 32);
		ringMesh24.geometry = ringGeometry24; 
		ringGeometry25.dispose();
		ringGeometry25 = new THREE.RingGeometry((inradius25 - guiParameters.circleWidth),inradius25, 32);
		ringMesh25.geometry = ringGeometry25; 
		ringGeometry26.dispose();
		ringGeometry26 = new THREE.RingGeometry((inradius26 - guiParameters.circleWidth),inradius26, 32);
		ringMesh26.geometry = ringGeometry26; 
		ringGeometry27.dispose();
		ringGeometry27 = new THREE.RingGeometry((inradius27 - guiParameters.circleWidth),inradius27, 32);
		ringMesh27.geometry = ringGeometry27; 
		ringGeometry28.dispose();
		ringGeometry28 = new THREE.RingGeometry((inradius28 - guiParameters.circleWidth),inradius28, 32);
		ringMesh28.geometry = ringGeometry28; 
		ringGeometry29.dispose();
		ringGeometry29 = new THREE.RingGeometry((inradius29 - guiParameters.circleWidth),inradius29, 32);
		ringMesh29.geometry = ringGeometry29; 
		ringGeometry30.dispose();
		ringGeometry30 = new THREE.RingGeometry((inradius30 - guiParameters.circleWidth),inradius30, 32);
		ringMesh30.geometry = ringGeometry30; 
		ringGeometry31.dispose();
		ringGeometry31 = new THREE.RingGeometry((inradius31 - guiParameters.circleWidth),inradius31, 32);
		ringMesh31.geometry = ringGeometry31; 
		ringGeometry32.dispose();
		ringGeometry32 = new THREE.RingGeometry((inradius32 - guiParameters.circleWidth),inradius32, 32);
		ringMesh32.geometry = ringGeometry32; 
	}

	updateCircleWidth();

	// generate the normals trough the incenter orthogonal to the face 
	// getNormalsVectors generates the coordinates for the current values of the parameterized surface 
	function getNormalsVectors(){
		var vector1;
		var vector2;

		var normals = [];
		vector1 = [];
		vector2 = [];
		vector1[0] = (1)-(0);
		vector1[1] = (1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (1.483163247594393)-(0);
		vector2[1] = (0.)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,1,0],[1.4831632475943928,0.,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1)-(0);
		vector1[1] = (-1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (1.483163247594393)-(0);
		vector2[1] = (0.)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,-1,0],[1.4831632475943928,0.,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1)-(1);
		vector1[1] = (-1)-(1);
		vector1[2] = (0)-(0);

		vector2[0] = (1.483163247594393)-(1);
		vector2[1] = (0.)-(1);
		vector2[2] = (1.048754789980658)-(0);

		var incenter = calulateIncenter([1,1,0],[ 1,-1,0],[1.4831632475943928,0.,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(1);
		vector1[1] = (1)-(1);
		vector1[2] = (0)-(0);

		vector2[0] = (0.)-(1);
		vector2[1] = (1.483163247594393)-(1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([1,1,0],[ -1,1,0],[0.,1.4831632475943928,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(1);
		vector1[1] = (0)-(1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (0.)-(1);
		vector2[1] = (1.483163247594393)-(1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([1,1,0],[ 0,0,-1.4142135623730951],[0.,1.4831632475943928,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(-1);
		vector1[1] = (0)-(1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (0.)-(-1);
		vector2[1] = (1.483163247594393)-(1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([-1,1,0],[ 0,0,-1.4142135623730951],[0.,1.4831632475943928,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1)-(0);
		vector1[1] = (1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (0.)-(0);
		vector2[1] = (1.483163247594393)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,1,0],[0.,1.4831632475943928,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(0);
		vector1[1] = (1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (0.)-(0);
		vector2[1] = (1.483163247594393)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,1,0],[0.,1.4831632475943928,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(1);
		vector1[1] = (1)-(1);
		vector1[2] = (0)-(0);

		vector2[0] = (0.)-(1);
		vector2[1] = (1.483163247594393)-(1);
		vector2[2] = (1.048754789980658)-(0);

		var incenter = calulateIncenter([1,1,0],[ -1,1,0],[0.,1.4831632475943928,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1)-(1);
		vector1[1] = (-1)-(1);
		vector1[2] = (0)-(0);

		vector2[0] = (1.483163247594393)-(1);
		vector2[1] = (0.)-(1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([1,1,0],[ 1,-1,0],[1.4831632475943928,0.,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(1);
		vector1[1] = (0)-(1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (1.483163247594393)-(1);
		vector2[1] = (0.)-(1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([1,1,0],[ 0,0,-1.4142135623730951],[1.4831632475943928,0.,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(1);
		vector1[1] = (0)-(-1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (1.483163247594393)-(1);
		vector2[1] = (0.)-(-1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([1,-1,0],[ 0,0,-1.4142135623730951],[1.4831632475943928,0.,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(0);
		vector1[1] = (-1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (-1.483163247594393)-(0);
		vector2[1] = (0.)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,-1,0],[-1.4831632475943928,0.,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(0);
		vector1[1] = (1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (-1.483163247594393)-(0);
		vector2[1] = (0.)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,1,0],[-1.4831632475943928,0.,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(-1);
		vector1[1] = (1)-(-1);
		vector1[2] = (0)-(0);

		vector2[0] = (-1.483163247594393)-(-1);
		vector2[1] = (0.)-(-1);
		vector2[2] = (1.048754789980658)-(0);

		var incenter = calulateIncenter([-1,-1,0],[ -1,1,0],[-1.4831632475943928,0.,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(1);
		vector1[1] = (-1)-(-1);
		vector1[2] = (0)-(0);

		vector2[0] = (0.)-(1);
		vector2[1] = (-1.483163247594393)-(-1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([1,-1,0],[ -1,-1,0],[0.,-1.4831632475943928,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(1);
		vector1[1] = (0)-(-1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (0.)-(1);
		vector2[1] = (-1.483163247594393)-(-1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([1,-1,0],[ 0,0,-1.4142135623730951],[0.,-1.4831632475943928,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(-1);
		vector1[1] = (0)-(-1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (0.)-(-1);
		vector2[1] = (-1.483163247594393)-(-1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([-1,-1,0],[ 0,0,-1.4142135623730951],[0.,-1.4831632475943928,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1)-(0);
		vector1[1] = (-1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (0.)-(0);
		vector2[1] = (-1.483163247594393)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ 1,-1,0],[0.,-1.4831632475943928,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(0);
		vector1[1] = (-1)-(0);
		vector1[2] = (0)-(1.414213562373095);

		vector2[0] = (0.)-(0);
		vector2[1] = (-1.483163247594393)-(0);
		vector2[2] = (1.048754789980658)-(1.414213562373095);

		var incenter = calulateIncenter([0,0,1.4142135623730951],[ -1,-1,0],[0.,-1.4831632475943928,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(1);
		vector1[1] = (-1)-(-1);
		vector1[2] = (0)-(0);

		vector2[0] = (0.)-(1);
		vector2[1] = (-1.483163247594393)-(-1);
		vector2[2] = (1.048754789980658)-(0);

		var incenter = calulateIncenter([1,-1,0],[ -1,-1,0],[0.,-1.4831632475943928,1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1)-(-1);
		vector1[1] = (1)-(-1);
		vector1[2] = (0)-(0);

		vector2[0] = (-1.483163247594393)-(-1);
		vector2[1] = (0.)-(-1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([-1,-1,0],[ -1,1,0],[-1.4831632475943928,0.,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(-1);
		vector1[1] = (0)-(-1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (-1.483163247594393)-(-1);
		vector2[1] = (0.)-(-1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([-1,-1,0],[ 0,0,-1.4142135623730951],[-1.4831632475943928,0.,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0)-(-1);
		vector1[1] = (0)-(1);
		vector1[2] = (-1.414213562373095)-(0);

		vector2[0] = (-1.483163247594393)-(-1);
		vector2[1] = (0.)-(1);
		vector2[2] = (-1.048754789980658)-(0);

		var incenter = calulateIncenter([-1,1,0],[ 0,0,-1.4142135623730951],[-1.4831632475943928,0.,-1.0487547899806575]);
		normals.push([vector1, vector2, incenter]);

	return normals;
	}
	// getNormalsCoordinates calculates the right coordinates for the ortogonality and fitting values from the gui 
	function getNormalsCoordinates(){
		var res = [];
		var normals = getNormalsVectors(); 
        for(var i = 0; i < normals.length; i++){
            var plus = [];
            var minus = [];

            minus[0] = normals[i][2][0] - (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            minus[1] = normals[i][2][1] - (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            minus[2] = normals[i][2][2] - (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            plus[0] = normals[i][2][0] + (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            plus[1] = normals[i][2][1] + (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            plus[2] = normals[i][2][2] + (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            res.push(minus[0]);
            res.push(minus[1]);
            res.push(minus[2]);
            res.push(plus[0]);
            res.push(plus[1]);
            res.push(plus[2]);
        }
        res = Float32Array.from(res);

    
		return res;
	}


    const normalsMaterial = new THREE.LineBasicMaterial( {
        color: 0x000000,
    } );
    
    const normalsGeometry = new THREE.BufferGeometry();
    normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
    var normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );

    function updateNormals(){
        normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
        normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );
    }
    
    normalsRoot.add(normalsLine);

    
	// generate automatic ranges for the intersections if the surface is not parameterized 
	guiParameters.maxX = 1.483163247594393;
	guiParameters.maxY = 1.483163247594393;
	guiParameters.maxZ = 1.414213562373095;
	guiParameters.minX = -1.483163247594393;
	guiParameters.minY = -1.483163247594393;
	guiParameters.minZ = -1.414213562373095;

	guiParameters.planeX = 0.;
	guiParameters.planeY = 0.;
	guiParameters.planeZ = 0.;
	var performanceOverlayEnabled = false;
	// --- end of generated output --- //

    const center = new THREE.Vector3(guiParameters.planeX, guiParameters.planeY, guiParameters.planeZ);
    controls.target = center;
    
    const planeFolder = gui.addFolder("Intersection Planes");
    planeFolder.add(guiParameters, 'planeXactive');
    planeFolder.add(guiParameters, 'planeX', guiParameters.minX*1.1, guiParameters.maxX*1.1);
    planeFolder.add(guiParameters, 'planeYactive');
    planeFolder.add(guiParameters, 'planeY', guiParameters.minY*1.1, guiParameters.maxY*1.1);
    planeFolder.add(guiParameters, 'planeZactive');
    planeFolder.add(guiParameters, 'planeZ', guiParameters.minZ*1.1, guiParameters.maxZ*1.1);
    
    camera.position.x = Math.min((1.1)*Math.abs(guiParameters.minX), -1)
    camera.position.y = Math.min((1.1)*Math.abs(guiParameters.minY), -1)
    camera.position.z = Math.min((1.1)*Math.abs(guiParameters.minZ), -1)
    camera.lookAt(guiParameters.planeX,guiParameters.planeY,guiParameters.planeZ);

    scene.background = new THREE.Color( 'white' );

    // add both roots to the scene
    scene.add( meshRoot );
    scene.add( wireRoot );
    scene.add( vertexRoot );
    scene.add( vertexlabelRoot );
    scene.add( edgeRoot );
    scene.add( ringRoot );
    scene.add( normalsRoot );
    scene.add( normalMeshRoot );

    //presave some current gui parameters to only update if they change
    var currentCircleWidth = guiParameters.circleWidth;

    function animate() {
        requestAnimationFrame( animate );
        meshRoot.rotation.x += guiParameters.speedX/100;
        meshRoot.rotation.y += guiParameters.speedY/100;
        meshRoot.rotation.z += guiParameters.speedZ/100;

        wireRoot.rotation.x += guiParameters.speedX/100;
        wireRoot.rotation.y += guiParameters.speedY/100;
        wireRoot.rotation.z += guiParameters.speedZ/100;

        vertexRoot.rotation.x += guiParameters.speedX/100;
        vertexRoot.rotation.y += guiParameters.speedY/100;
        vertexRoot.rotation.z += guiParameters.speedZ/100;

        vertexlabelRoot.rotation.x += guiParameters.speedX/100;
        vertexlabelRoot.rotation.y += guiParameters.speedY/100;
        vertexlabelRoot.rotation.z += guiParameters.speedZ/100;

        edgeRoot.rotation.x += guiParameters.speedX/100;
        edgeRoot.rotation.y += guiParameters.speedY/100;
        edgeRoot.rotation.z += guiParameters.speedZ/100;

        ringRoot.rotation.x += guiParameters.speedX/100;
        ringRoot.rotation.y += guiParameters.speedY/100;
        ringRoot.rotation.z += guiParameters.speedZ/100;

        normalsRoot.rotation.x += guiParameters.speedX/100;
        normalsRoot.rotation.y += guiParameters.speedY/100;
        normalsRoot.rotation.z += guiParameters.speedZ/100;

        normalMeshRoot.rotation.x += guiParameters.speedX/100;
        normalMeshRoot.rotation.y += guiParameters.speedY/100;
        normalMeshRoot.rotation.z += guiParameters.speedZ/100;

        //update the light when the camera moves (with orbitcontrols)
        light.position.set(camera.position.x, camera.position.y, camera.position.z);

        planeX.constant = guiParameters.planeX;
        planeY.constant = guiParameters.planeY;
        planeZ.constant = guiParameters.planeZ;

        activePlanes = [];
        if(guiParameters.planeXactive){
            activePlanes.push(planeX);
        }
        if(guiParameters.planeYactive){
            activePlanes.push(planeY);
        }
        if(guiParameters.planeZactive){
            activePlanes.push(planeZ);
        }

        if(vertexParametriziation){
            updateFaceCoordinates();
            if(guiParameters.edgeVisibility){
                updateEdgeCoordinates();
            }
            if(guiParameters.vertexlabelVisibility || guiParameters.vertexVisibility){
                updateVertexCoordinates();
            }
            if(guiParameters.circleVisibility){
                updateCircles();
            }
        }                

        //update stuff that changes from the gui
        meshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        normalMeshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(!guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        edgeRoot.traverse( function( node ) {
            if ( node instanceof Line2 ) {
                node.material.visible = guiParameters.edgeVisibility;
                node.material.linewidth = guiParameters.edgeWidth/100;
            }
            if ( node instanceof THREE.LineSegments ) {
                node.material.visible = guiParameters.edgeVisibility;
            }
        } );

        vertexRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.visible = guiParameters.vertexVisibility;
                node.scale.setScalar(guiParameters.vertexSize);
            }
        } );

        vertexlabelRoot.traverse( function( node ) {
            if( node instanceof CSS2DObject) {
                node.visible = guiParameters.vertexlabelVisibility;
            }
        } );

        ringRoot.traverse( function( node ) {
            if( node instanceof THREE.Mesh) {
                node.visible = guiParameters.circleVisibility;
            }
        } );

        normalsRoot.traverse( function( node ) {
            if( node instanceof THREE.LineSegments) {
                node.visible = guiParameters.normalsVisibility;
            }
        } );

        // update the circle width
        if(guiParameters.circleVisibility && currentCircleWidth != guiParameters.circleWidth){
            updateCircleWidth();
            currentCircleWidth = guiParameters.circleWidth;
        }

        //update the normals length 
        if(guiParameters.normalsVisibility){
            updateNormals();
        }

        //update controls
        controls.update();

        //update performance overlay of enabled
        if(performanceOverlayEnabled){
            stats.update();
        }

        renderer.localClippingEnabled = true;

        renderer.render( scene, camera );
        labelRenderer.render( scene, camera );
    }
    animate();

    //resize of window size changes
    window.addEventListener( 'resize', onWindowResize );
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        labelRenderer.setSize( window.innerWidth, window.innerHeight );
    }
</script>

</body>
</html>